# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Builds a .unitypackage and Unity Package Manager tarball to the build/bin
# directory.

cmake_minimum_required(VERSION 3.17)

project(falken_unity NONE)

set(FALKEN_SDK_VERSION "0.0.1" CACHE STRING
  "Version of the plugin being built."
)
set(INSTALL_PATH "${CMAKE_CURRENT_LIST_DIR}" CACHE PATH
  "Path to the Unity project to install the plugin into."
)
set(EDM4U_VERSION "master" CACHE STRING
  "Version of EDM4U to build with."
)

set(FALKEN_COMPILE_UNITY OFF CACHE BOOL "Compile C# assembly for Unity.")
set(FALKEN_COMPILE_CSHARP ON CACHE BOOL "Compile C# assembly for Mono / .NET.")
set(FALKEN_PROJECT_ID "" CACHE STRING "Project ID for integration tests.")
set(FALKEN_API_KEY "" CACHE STRING "API Key for integration tests.")
set(FALKEN_JSON_CONFIG_FILE "" CACHE STRING
    "JSON configuration file for integration tests. This can be used instead of
  FALKEN_PROJECT_ID and FALKEN_API_KEY."
)
set(FALKEN_RUN_CSHARP_TESTS ON CACHE BOOL "Whether to run C# tests.")
set(FALKEN_TESTAPP_ENABLE_TEST OFF CACHE BOOL "Disable C++ testapp" FORCE)
set(FALKEN_ENABLE_CPP_UNIT_TESTS OFF CACHE BOOL "Disable C++ SDK unit tests" FORCE)

# Configure Python binary using the PYTHON variable.
if(CMAKE_SYSTEM_NAME MATCHES "Windows")
  set(DEFAULT_PYTHON "python")
else()
  set(DEFAULT_PYTHON "python3")
endif()
set(PYTHON "${DEFAULT_PYTHON}" CACHE STRING
  "Python executable to use."
)

# Set the version string.
# TODO(b/185930119) This block and download_source.py should be removed when
# forking to the OSS branch.
if("${FALKEN_SDK_VERSION}" STREQUAL "" OR
   # If we're downloading sources from a CITC client that have potentially been
   # modified, reset the release version number.
   (NOT (DOWNLOAD_MACHINE STREQUAL "") AND
    (DOWNLOAD_CHANGELIST STREQUAL "head" OR
     (NOT DOWNLOAD_CITC_CLIENT STREQUAL ""))))
  set(FALKEN_UNITY_SDK_VERSION "0.0.0")
else()
  set(FALKEN_UNITY_SDK_VERSION "${FALKEN_SDK_VERSION}")
endif()

set(FALKEN_CPP_SDK_CSHARP ON CACHE BOOL "Generate C++ SDK C# bindings." FORCE)

if(FALKEN_RUN_CSHARP_TESTS)
  enable_testing()
endif()

# Output directories.
set(BUILD_DIR "${PROJECT_BINARY_DIR}/falken_unity_build")
set(BIN_DIR "${BUILD_DIR}/bin")
set(INTERMEDIATES_DIR "${BUILD_DIR}/intermediates")
set(STAGING_DIR "${INTERMEDIATES_DIR}/staging")
set(STAGING_ASSETS_DIR "${STAGING_DIR}/Assets")

# Source directories.
set(ASSETS_DIR "${CMAKE_CURRENT_LIST_DIR}/Assets")
# Add the C++ SDK cmake subdirectory to the list of directories to search for
# packages to include when using find_package() for Find<PackageName>.cmake.
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/../cpp")

# Save the SDK Version in a file
file(WRITE "${STAGING_ASSETS_DIR}/sdk_version.txt" "SDK version: ${FALKEN_SDK_VERSION}")

# Generate targets to recursively copy files from one directory to another.
# NOTE: If files are added to or removed from the source directory cmake
# configuration will need to be run to pick up changed files.
#
# Args:
#   TARGET: Name of the target to create (required).
#   SOURCE_DIR: Directory to copy from.  If SOURCE_FILES is specified each path
#     in SOURCE_FILES is relative to this directory.
#     (required if SOURCE_FILES isn't specifeid).
#   TARGET_DIR: Directory to copy to (required).
#   SOURCE_FILES: List of files to copy relative to SOURCE_DIR.
#   INCLUDE_REGEX: Regular expression which matches paths to include in the
#     copy operation.  If this isn't specified all source paths are included.
#   EXCLUDE_REGEX: Regular expression which matches paths to exclude from the
#     copy operation.
#   OUTPUT_FILES_VAR: Accepts the name of a variable to store the list of
#     output files generated by the copy target.
#   DEPENDS: Additional dependencies for the generated target.
macro(copy_directory)
  cmake_parse_arguments(ARGS
    ""
    "TARGET;SOURCE_DIR;TARGET_DIR;INCLUDE_REGEX;EXCLUDE_REGEX;OUTPUT_FILES_VAR"
    "SOURCE_FILES;DEPENDS"
    ${ARGN}
  )
  set(TARGET_FILENAMES "")
  if(ARGS_SOURCE_FILES)
    set(FILES_TO_COPY ${ARGS_SOURCE_FILES})
  else()
    file(GLOB_RECURSE FILES_TO_COPY
      RELATIVE "${ARGS_SOURCE_DIR}"
      "${ARGS_SOURCE_DIR}/*")
  endif()

  foreach(FILENAME ${FILES_TO_COPY})
    set(SOURCE_FILENAME "${ARGS_SOURCE_DIR}/${FILENAME}")
    set(TARGET_FILENAME "${ARGS_TARGET_DIR}/${FILENAME}")
    set(INCLUDE 1)
    set(EXCLUDE "")

    if (ARGS_INCLUDE_REGEX)
      string(REGEX MATCH "${ARGS_INCLUDE_REGEX}" INCLUDE_MATCH
        "${SOURCE_FILENAME}")
      if (INCLUDE_MATCH STREQUAL "")
        set(INCLUDE 0)
      endif()
    endif()
    if(ARGS_EXCLUDE_REGEX)
      string(REGEX MATCH "${ARGS_EXCLUDE_REGEX}" EXCLUDE "${SOURCE_FILENAME}")
    endif()

    if(INCLUDE EQUAL 1 AND EXCLUDE STREQUAL "")
      list(APPEND TARGET_FILENAMES "${TARGET_FILENAME}")
      add_custom_command(
        OUTPUT "${TARGET_FILENAME}"
        COMMAND ${CMAKE_COMMAND} -E copy "${SOURCE_FILENAME}"
          "${TARGET_FILENAME}"
        DEPENDS "${SOURCE_FILENAME}" ${ARGS_DEPENDS}
      )
    endif()
  endforeach(FILENAME)

  if(ARGS_OUTPUT_FILES_VAR)
    set(${ARGS_OUTPUT_FILES_VAR} ${TARGET_FILENAMES})
  endif()
  add_custom_target(${ARGS_TARGET}
    DEPENDS ${TARGET_FILENAMES} ${ARGS_DEPENDS})
endmacro(copy_directory)


include(ExternalProject)
# Include EDM4U to use the Unity plugin packaging script.
ExternalProject_Add(
  edm4u
  GIT_REPOSITORY https://github.com/googlesamples/unity-jar-resolver.git
  GIT_TAG ${EDM4U_VERSION}
  GIT_SHALLOW 1
  PREFIX ${INTERMEDIATES_DIR}
  CONFIGURE_COMMAND ""
  BUILD_COMMAND ""
  INSTALL_COMMAND ""
  TEST_COMMAND ""
)
ExternalProject_Get_Property(edm4u SOURCE_DIR)
set(EXPORT_UNITY_PACKAGE
  "${SOURCE_DIR}/source/ExportUnityPackage/export_unity_package.py")
set(IMPORT_UNITY_PACKAGE
  "${SOURCE_DIR}/source/ImportUnityPackage/import_unity_package.py")

# Install absl-py for the export script.
add_custom_target(
  install_absl_py
  COMMAND "${PYTHON}" -m pip install --user absl-py
)

# Install PyYAML for the export script.
add_custom_target(
  install_pyyaml
  COMMAND "${PYTHON}" -m pip install --user pyyaml
)

# Include the C++ SDK project.
find_package(falken REQUIRED)

set(SCRIPTS_PATH "Assets/Falken/Scripts")
set(SWIG_GEN_ASSETS_PATH "${SCRIPTS_PATH}/Gen")

set(FALKEN_NATIVE_PLUGINS_ASSETS_PATH "Assets/Falken/Core/Plugins/x86_64")
if(CMAKE_SYSTEM_VERSION MATCHES "Ggp")
  # Stadia Build
  set(FALKEN_NATIVE_PLUGINS_ASSETS_PATH "Assets/Falken/Core/Plugins/Stadia")
endif()

# Copy the plugin into the build's staging area.
set(REGEX "(")
set(REGEX "${REGEX}.*${FALKEN_NATIVE_PLUGINS_ASSETS_PATH}.*(so|bundle|dll)|")
set(REGEX "${REGEX}.*${SWIG_GEN_ASSETS_PATH}.*|")
set(REGEX "${REGEX}.*\\.meta\\$)")
copy_directory(TARGET copy_asset_files_to_staging
  SOURCE_DIR "${ASSETS_DIR}"
  TARGET_DIR "${STAGING_ASSETS_DIR}"
  EXCLUDE_REGEX "${REGEX}"
  OUTPUT_FILES_VAR ASSET_FILES_IN_STAGING
)

# Copy asset metadata into the build's staging area.
# The .meta files are copied separately so the tree can be used as a template
# for components to overlay in the staging area.
copy_directory(TARGET copy_asset_meta_files_to_staging
  SOURCE_DIR "${ASSETS_DIR}"
  TARGET_DIR "${STAGING_ASSETS_DIR}"
  INCLUDE_REGEX ".*\\.meta\\$"
  OUTPUT_FILES_VAR ASSET_META_FILES_IN_STAGING
)

# Copy license to the staging area.
set(LICENSE_FILENAME "${STAGING_ASSETS_DIR}/Falken/LICENSE.txt")
add_custom_command(
  OUTPUT "${LICENSE_FILENAME}"
  COMMAND ${CMAKE_COMMAND} -E copy "${FALKEN_CPP_LICENSE}" "${LICENSE_FILENAME}"
  DEPENDS "${FALKEN_CPP_LICENSE}"
)

set(README_SOURCE_FILENAME "${CMAKE_CURRENT_LIST_DIR}/readme.md")
set(README_FILENAME "${STAGING_ASSETS_DIR}/Falken/readme.md")
add_custom_command(
  OUTPUT "${README_FILENAME}"
  COMMAND ${CMAKE_COMMAND} -E copy
    "${README_SOURCE_FILENAME}" "${README_FILENAME}"
  DEPENDS "${README_SOURCE_FILENAME}"
)

if(FALKEN_COMPILE_UNITY OR FALKEN_COMPILE_CSHARP)
  list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/cmake")
  include(csharp)
  include(nunit)

  # C# source files.
  file(GLOB FALKEN_ASSETS_FALKEN_SCRIPTS_CSHARP_SOURCES
    CONFIGURE_DEPENDS
    "${SCRIPTS_PATH}/*.cs"
  )
  set(FALKEN_ALL_CSHARP_SOURCES
    # Source files.
    ${FALKEN_ASSETS_FALKEN_SCRIPTS_CSHARP_SOURCES}
    # Generated source files.
    ${FALKEN_CSHARP_SOURCES}
  )
  file(GLOB FALKEN_TESTS_CSHARP_SOURCES
    CONFIGURE_DEPENDS
    "${ASSETS_DIR}/Falken/Tests/*.cs"
  )

  # .NET framework to compile against.
  set(DOTNET_FRAMEWORK_VERSION 4.5)

  # Generate a Falken configuration file for tests.
  if(("${FALKEN_PROJECT_ID}" STREQUAL "" OR "${FALKEN_API_KEY}" STREQUAL "") AND
     ("${FALKEN_JSON_CONFIG_FILE}" STREQUAL ""))
    message(WARNING
      "FALKEN_PROJECT_ID and FALKEN_API_KEY or FALKEN_JSON_CONFIG_FILE must "
      "be set to run tests."
    )
  endif()
  set(FALKEN_TEST_CONFIG "${INTERMEDIATES_DIR}/falken_config.json")
  if(NOT "${FALKEN_JSON_CONFIG_FILE}" STREQUAL "")
    configure_file("${FALKEN_JSON_CONFIG_FILE}" "${FALKEN_TEST_CONFIG}"
      COPYONLY
    )
  else()
    set(VAR_PROJECT_ID "${FALKEN_PROJECT_ID}")
    set(VAR_API_KEY "${FALKEN_API_KEY}")
    configure_file(csharp/falken_config_json.template "${FALKEN_TEST_CONFIG}"
      @ONLY
      NEWLINE_STYLE CRLF
    )
    unset(VAR_PROJECT_ID)
    unset(VAR_API_KEY)
  endif()
endif()

# Build Unity C# DLL.
if(FALKEN_COMPILE_UNITY)
  find_package(Unity REQUIRED)
  set(UNITY_DEFINES UNITY_5_3_OR_NEWER)

  CSharpAddLibrary(
    falken_csharp_unity_dll
    MODULE
      Falken.Unity
    FRAMEWORK_VERSION
      "${DOTNET_FRAMEWORK_VERSION}"
    BINARY_DIR
      "${INTERMEDIATES_DIR}"
    DEFINES
      ${UNITY_DEFINES}
    SOURCES
      ${FALKEN_ALL_CSHARP_SOURCES}
      "${CMAKE_CURRENT_LIST_DIR}/csharp/Falken.Unity/AssemblyInfo.cs"
    REFERENCES
      unity_engine
      unity_engine_core_module
      unity_engine_physics_module
    GENERATE_DOCUMENTATION
    BINARY_DIR
      "${INTERMEDIATES_DIR}"
    COPY_FILES
      falken_csharp_sdk
    BUILD_EXE
      "${UNITY_CSHARP_BUILD_EXE}"
    ALL
  )
  CSharpAddLibrary(
    falken_csharp_unity_tests_dll
    MODULE
      Falken.Unity.Tests
    FRAMEWORK_VERSION
      "${DOTNET_FRAMEWORK_VERSION}"
    BINARY_DIR
      "${INTERMEDIATES_DIR}"
    DEFINES
      ${UNITY_DEFINES}
    SOURCES
      ${FALKEN_TESTS_CSHARP_SOURCES}
      "${CMAKE_CURRENT_LIST_DIR}/csharp/Falken.Unity.Tests/AssemblyInfo.cs"
    REFERENCES
      falken_csharp_unity_dll
      nunit_framework
      unity_engine
      unity_engine_core_module
      unity_engine_test_runner
    DEPENDS
      falken_csharp_dll
    BUILD_EXE
      "${UNITY_CSHARP_BUILD_EXE}"
    ALL
  )
endif()

# Build Mono C# DLL.
if(FALKEN_COMPILE_CSHARP)
  CSharpAddLibrary(
    falken_csharp_dll
    MODULE
      Falken
    FRAMEWORK_VERSION
      "${DOTNET_FRAMEWORK_VERSION}"
    BINARY_DIR
      "${INTERMEDIATES_DIR}"
    SOURCES
      ${FALKEN_ALL_CSHARP_SOURCES}
      "${CMAKE_CURRENT_LIST_DIR}/csharp/Falken/AssemblyInfo.cs"
    GENERATE_DOCUMENTATION
    COPY_FILES
      falken_csharp_sdk
    ALL
  )
  CSharpAddLibrary(
    falken_csharp_tests_dll
    MODULE
      Falken.Tests
    FRAMEWORK_VERSION
      "${DOTNET_FRAMEWORK_VERSION}"
    BINARY_DIR
      "${INTERMEDIATES_DIR}"
    DEFINES
      NUNIT_3
    SOURCES
      ${FALKEN_TESTS_CSHARP_SOURCES}
      "${CMAKE_CURRENT_LIST_DIR}/csharp/Falken.Tests/AssemblyInfo.cs"
    REFERENCES
      falken_csharp_dll
      nunit_framework
    COPY_FILES
      "${FALKEN_TEST_CONFIG}"
    ALL
   )
   NUnitTest(
     falken_csharp_tests
     TEST_TARGET falken_csharp_tests_dll
   )
endif()

# Copy the C++ shared library into the staging area.
if(CMAKE_SYSTEM_NAME MATCHES "Darwin")
  set(FALKEN_CPP_FILENAME falken_csharp_sdk.bundle)
elseif(CMAKE_SYSTEM_NAME MATCHES "Linux")
  set(FALKEN_CPP_FILENAME libfalken_csharp_sdk.so)
elseif(CMAKE_SYSTEM_NAME MATCHES "Windows")
  set(FALKEN_CPP_FILENAME falken_csharp_sdk.dll)
else()
  message(FATAL_ERROR "Building for ${CMAKE_SYSTEM_NAME} not supported")
endif()

set(FALKEN_CORE_IN_STAGING
  "${STAGING_DIR}/${FALKEN_NATIVE_PLUGINS_ASSETS_PATH}/${FALKEN_CPP_FILENAME}"
)
add_custom_command(
  OUTPUT "${FALKEN_CORE_IN_STAGING}"
  COMMAND ${CMAKE_COMMAND}
    -E copy
    "$<TARGET_FILE:falken_csharp_sdk>"
    "${FALKEN_CORE_IN_STAGING}"
  DEPENDS
    falken_csharp_sdk
)
add_custom_target(copy_falken_core_to_staging
  DEPENDS "${FALKEN_CORE_IN_STAGING}"
)

# Copy C# files into the staging area.
copy_directory(TARGET copy_csharp_gen_to_staging
  SOURCE_DIR "${FALKEN_CSHARP_SOURCES_DIR}"
  TARGET_DIR "${STAGING_DIR}/${SWIG_GEN_ASSETS_PATH}/"
  SOURCE_FILES ${FALKEN_CSHARP_SOURCES_RELATIVE_PATHS}
  OUTPUT_FILES_VAR PROTO_GEN_FILES_IN_STAGING
  DEPENDS falken_csharp_sdk
)

# Copy all components into the staging area.
add_custom_target(
  stage_plugin ALL
  DEPENDS
    "${LICENSE_FILENAME}"
    "${README_FILENAME}"
    copy_asset_files_to_staging
    copy_asset_meta_files_to_staging
    copy_falken_core_to_staging
    copy_csharp_gen_to_staging
)

list(APPEND STAGE_PLUGIN_FILES
  "${ASSET_FILES_IN_STAGING}"
  "${ASSET_META_FILES_IN_STAGING}"
  "${FALKEN_CORE_IN_STAGING}"
  "${PROTO_GEN_FILES_IN_STAGING}"
)

# Export the .unitypackage.
set(FALKEN_UNITYPACKAGE "${BIN_DIR}/falken.unitypackage")
add_custom_command(
  OUTPUT "${FALKEN_UNITYPACKAGE}"
  COMMAND "${PYTHON}" "${EXPORT_UNITY_PACKAGE}"
    --assets_dir "${STAGING_ASSETS_DIR}"
    --config_file "${CMAKE_CURRENT_LIST_DIR}/export_unity_package_config.json"
    --guids_file "${CMAKE_CURRENT_LIST_DIR}/export_unity_package_guids.json"
    --output_dir "${BIN_DIR}"
    --plugins_version ${FALKEN_SDK_VERSION}
    --verbosity -1
    --nooutput_upm
  DEPENDS
    edm4u
    install_absl_py
    install_pyyaml
    stage_plugin
    ${STAGE_PLUGIN_FILES}
  VERBATIM
)

add_custom_target(
  build_unitypackage ALL
  DEPENDS stage_plugin "${BIN_DIR}/falken.unitypackage"
)

# Export the Unity Package Manager tarball.
add_custom_command(
  OUTPUT "${BIN_DIR}/com.google.falken-${FALKEN_SDK_VERSION}.tgz"
  COMMAND "${PYTHON}" "${EXPORT_UNITY_PACKAGE}"
    --assets_dir "${STAGING_ASSETS_DIR}"
    --config_file "${CMAKE_CURRENT_LIST_DIR}/export_unity_package_config.json"
    --guids_file "${CMAKE_CURRENT_LIST_DIR}/export_unity_package_guids.json"
    --output_dir "${BIN_DIR}"
    --plugins_version ${FALKEN_SDK_VERSION}
    --verbosity -1
    --nooutput_unitypackage
    --output_upm
  DEPENDS
    edm4u
    install_absl_py
    stage_plugin
    ${STAGE_PLUGIN_FILES}
  VERBATIM
)

add_custom_target(
  build_upmpackage ALL
  DEPENDS stage_plugin "${BIN_DIR}/com.google.falken-${FALKEN_SDK_VERSION}.tgz"
)

if(INSTALL_PATH)
  set(INSTALLED_PLUGIN_DIR "${INSTALL_PATH}/Assets/Falken")
  # Uninstall the plugin from the target project if the target project is
  # not the source directory.
  if(NOT "${INSTALL_PATH}" STREQUAL "${CMAKE_CURRENT_LIST_DIR}")
    if(${CMAKE_VERSION} VERSION_LESS "3.17.0")
      add_custom_command(
        OUTPUT "${INSTALL_PATH}_always_delete_and_copy"
        COMMAND ${CMAKE_COMMAND} -E remove_directory
          "${INSTALLED_PLUGIN_DIR}"
        DEPENDS build_unitypackage
        VERBATIM
      )
    else()
      add_custom_command(
        OUTPUT "${INSTALL_PATH}_always_delete_and_copy"
        COMMAND ${CMAKE_COMMAND} -E rm -rf
          "${INSTALLED_PLUGIN_DIR}"
          "${INSTALLED_PLUGIN_DIR}.meta"
        DEPENDS build_unitypackage
        VERBATIM
      )
    endif()
  else()
    add_custom_command(
      OUTPUT "${INSTALL_PATH}_always_delete_and_copy"
      COMMAND ${CMAKE_COMMAND} -E echo "Skipping uninstall"
      DEPENDS build_unitypackage)
  endif()
  add_custom_target(
    uninstall_plugin
    DEPENDS "${INSTALL_PATH}_always_delete_and_copy")

  # Install files from the staging area into the project.
  add_custom_command(
    OUTPUT "${INSTALL_PATH}_always_install"
    COMMAND "${PYTHON}" "${IMPORT_UNITY_PACKAGE}"
      --packages "${FALKEN_UNITYPACKAGE}"
      --projects "${INSTALL_PATH}"
    DEPENDS
      install_absl_py
      "${FALKEN_UNITYPACKAGE}"
      save_install_config
      uninstall_plugin
  )
  add_custom_target(
    install_plugin
    DEPENDS "${INSTALL_PATH}_always_install"
  )
endif()

if(FALKEN_COMPILE_CSHARP)
  # Set CPack variables.
  set(CPACK_PACKAGE_NAME falken_csharp_sdk)
  set(CPACK_PACKAGE_VENDOR "Google")
  set(CPACK_PACKAGE_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/packaging")
  set(CPACK_PACKAGE_DESCRIPTION "Falken")
  set(CPACK_PACKAGE_VERSION "${FALKEN_SDK_VERSION}")
  set(CPACK_PACKAGE_FILE_NAME
    "${CPACK_PACKAGE_NAME}-${CPACK_PACKAGE_VERSION}-${FALKEN_SDK_TARGET}"
  )
  set(CPACK_SOURCE_GENERATOR "ZIP")
  set(CPACK_INCLUDE_TOPLEVEL_DIRECTORY OFF)
  set(CPACK_COMPONENTS_ALL falken_csharp_dll)
  # Add the build type to the package name on Windows since we need to
  # redistribute libraries built against the Debug and Release runtime
  # libraries.
  if(CMAKE_SYSTEM_NAME MATCHES "Windows")
    set(CPACK_PACKAGE_FILE_NAME
      "${CPACK_PACKAGE_FILE_NAME}-\${CPACK_BUILD_CONFIG}"
    )
  endif()

  set(FALKEN_CSHARP_VERSION_TXT
    "${CMAKE_CURRENT_BINARY_DIR}/falken_csharp_version.txt"
  )
  execute_process(COMMAND ${CMAKE_COMMAND} -E copy
    "${FALKEN_CPP_VERSION_TXT}"
    "${FALKEN_CSHARP_VERSION_TXT}"
  )

  get_target_property(FALKEN_CSHARP_DLL_NAME falken_csharp_dll
    LIBRARY_OUTPUT_NAME
  )
  get_target_property(FALKEN_CSHARP_DLL_SYMBOLS falken_csharp_dll
    CSHARP_LIBRARY_SYMBOLS
  )
  get_target_property(FALKEN_CSHARP_DLL_DOCS falken_csharp_dll
    CSHARP_LIBRARY_DOCUMENTATION
  )
  get_target_property(FALKEN_CSHARP_DLL_DIR falken_csharp_dll
    LIBRARY_OUTPUT_DIRECTORY
  )
  install(
    FILES
      "${FALKEN_CSHARP_VERSION_TXT}"
      "${FALKEN_CPP_LICENSE}"
      "${FALKEN_CSHARP_DLL_DIR}/${FALKEN_CSHARP_DLL_NAME}"
      "${FALKEN_CSHARP_DLL_DIR}/${FALKEN_CSHARP_DLL_SYMBOLS}"
      "${FALKEN_CSHARP_DLL_DIR}/${FALKEN_CSHARP_DLL_DOCS}"
      "${CMAKE_CURRENT_LIST_DIR}/csharp/readme.md"
    DESTINATION
      "."
    COMPONENT
      falken_csharp
  )
  install(
    TARGETS falken_csharp_sdk
    RUNTIME DESTINATION "."
    LIBRARY DESTINATION "."
    ARCHIVE DESTINATION "."
    COMPONENT falken_csharp
  )
  # Always leave this install target at the end. Every install rule
  # is called in the order they were added, so we can ensure that everything
  # is ready to be modified when calling this cmake script.
  include(CPack)
endif()
